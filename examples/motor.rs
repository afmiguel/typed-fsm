//! Motor Control System Example
//!
//! This example demonstrates a real-world use case: controlling a motor with safety checks.
//! It showcases:
//! - Stateful states (Running carries target_speed, Error carries error code)
//! - Entry/exit actions for hardware control
//! - Safety-critical transitions (overspeed protection)
//! - Manual error recovery (safety latch pattern)

use typed_fsm::{state_machine, Transition};

// ============================================================================
// 1. Hardware Abstraction Layer (Context)
// ============================================================================

/// Represents the shared state of the system (Sensors, Actuators, Globals).
/// In a real embedded project, this would hold references to Peripherals (GPIO, PWM).
#[derive(Debug)]
pub struct MotorContext {
    /// Current reading from the Hall Effect sensor
    pub current_rpm: u32,
    /// Current temperature from the thermistor
    pub temperature: f32,
}

impl MotorContext {
    /// Helper to simulate logging to a serial console
    fn log(&self, msg: &str) {
        // In a real scenario: serial.write(msg)
        println!(
            "[HW-LOG] {} | T: {:.1}C | RPM: {}",
            msg, self.temperature, self.current_rpm
        );
    }
}

// ============================================================================
// 2. System Events (Inputs)
// ============================================================================

/// Events that drive the State Machine.
/// These can be generated by Interrupt Service Routines (ISRs), timers, or user input.
#[derive(Debug)]
pub enum Input {
    /// User pressed the physical Start button
    StartButton,
    /// User pressed the physical Stop/Reset button
    StopButton,
    /// Periodic update from the speed sensor (contains data!)
    SensorTick { rpm: u32 },
}

// ============================================================================
// 3. State Machine Definition
// ============================================================================

// This macro generates the 'enum MotorFSM' and its 'dispatch' logic.
state_machine! {
    Name: MotorFSM,
    Context: MotorContext,
    Event: Input,

    States: {
        // --------------------------------------------------------------------
        // State: IDLE
        // Description: The system is powered but the motor is disengaged.
        // --------------------------------------------------------------------
        Idle => {
            // Entry Action: Executed once when entering this state
            entry: |ctx| {
                ctx.log("System READY. Waiting for user command...");
            }

            // Process Action: Executed on every event
            process: |_ctx, evt| {
                match evt {
                    Input::StartButton => {
                        println!(">> COMMAND: Start sequence initiated.");
                        // Transition to Running with a specific payload (target speed)
                        Transition::To(MotorFSM::Running { target_speed: 1000 })
                    },
                    // Ignore sensor ticks while idle
                    _ => Transition::None
                }
            }
        },

        // --------------------------------------------------------------------
        // State: RUNNING
        // Description: Motor is spinning. This state holds memory (target_speed).
        // --------------------------------------------------------------------
        Running { target_speed: u32 } => {
            entry: |_ctx| {
                // Note: 'target_speed' is available here automatically
                println!(">> ACTUATOR: PWM Enabled. Target: {} RPM", target_speed);
            }

            process: |ctx, evt| {
                match evt {
                    Input::StopButton => Transition::To(MotorFSM::Idle),

                    // Pattern Matching: Extract 'rpm' directly from the event
                    Input::SensorTick { rpm } => {
                        // Update the hardware context
                        ctx.current_rpm = *rpm;

                        // SAFETY CHECK: Overspeed Protection
                        // Note: 'target_speed' is a reference (&mut u32), so we dereference with '*'
                        if *rpm > *target_speed + 500 {
                            println!("!! SAFETY VIOLATION: Overspeed ({} > {})", rpm, target_speed);
                            // Critical Failure -> Transition to Error State
                            return Transition::To(MotorFSM::Error { code: 0xE1 });
                        }

                        ctx.log("PID Control Loop Active");
                        Transition::None
                    },
                    _ => Transition::None
                }
            }

            exit: |_ctx| {
                println!("<< ACTUATOR: PWM Disabled (Coasting).");
            }
        },

        // --------------------------------------------------------------------
        // State: ERROR
        // Description: Safety Latch. Only a manual reset can clear this state.
        // --------------------------------------------------------------------
        Error { code: u16 } => {
            entry: |_ctx| {
                println!("!! SYSTEM HALT. Error Code: {:#X}", code);
                println!("!! ACTION REQUIRED: Press STOP to reset.");
            }

            process: |_ctx, evt| {
                match evt {
                    // Only the StopButton allows exiting the Error state
                    Input::StopButton => {
                        println!(">> MANUAL RESET: Confirmed.");
                        Transition::To(MotorFSM::Idle)
                    },
                    _ => Transition::None
                }
            }
        }
    }
}

// ============================================================================
// 4. Main Loop (Simulation)
// ============================================================================

fn main() {
    // 1. Initialize Hardware Context (Sensors/Actuators)
    let mut ctx = MotorContext {
        current_rpm: 0,
        temperature: 45.2,
    };

    // 2. Initialize State Machine Memory (Starts in Idle)
    let mut machine = MotorFSM::Idle;

    println!("--- Firmware Boot Sequence ---");

    // 3. CRITICAL: Execute the 'Entry' action of the initial state.
    // Without this, the 'Idle' entry logic would not run until a transition occurred.
    machine.init(&mut ctx);

    println!("--- Event Loop Start ---");

    // 4. Simulation Scenario (A list of events occurring over time)
    let scenario = vec![
        Input::StartButton,              // User starts motor
        Input::SensorTick { rpm: 500 },  // Motor accelerating
        Input::SensorTick { rpm: 1000 }, // Reached target
        Input::SensorTick { rpm: 1600 }, // FAULT: Overspeed!
        Input::StartButton,              // User tries to restart (Should be ignored)
        Input::StopButton,               // User resets the alarm
        Input::StartButton,              // User starts again
        Input::StopButton,               // Normal stop
    ];

    // 5. The "Game Loop" / "Super Loop"
    for event in scenario {
        // Dispatch the event to the state machine
        machine.dispatch(&mut ctx, &event);
    }

    println!("--- Simulation End ---");
}
